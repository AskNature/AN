'use strict';

/**
 * @fileOverview OrientDB model object
 * @author Scott Halstvedt <scott.halstvedt@biomimicry.org>
 */

var _ = require('lodash');
var crypto = require('crypto');
var async = require('async');
var db = require('../config/database').db;

// Defines whether a masterid is autogenerated for the object, or if it is specified manually
var autoGenerateId = false;

/**
 * Constructs a generic Model object.
 * @class
 * @property {string} entityClass The name of the OrientDB class this model is bound to.
 * @property {object[]} fields A list of the fields that belong in the schema.
 * @property {object[]} relationships A list of the relationships that belong in the schema.
 * @returns {Model} A Model object.
 */
var ConstructModel = function(entityClass, fields, relationships) {
    var Model = function(masterid, attributes, rid) {
	// sets all fields specified in the schema to null
	_.forEach(fields, function(field) {
	    //console.log(field);
	    this[field] = null;
	}, this);

	// assigns provided field values
	_.assign(this, _.pick(attributes, fields));

	// assigns the provided masterid
	this.masterid = masterid;

	this._loadRelationships = function(object, callback) {
	    // map
	    //db.select(relationship_fields).from(relationshipName)

	    // map and do get async on models to reduce code duplication
	    // only map if field is object
	    // although this breaks the ANQL
	    // to fix, create Models inline here

	    /*db.query('SELECT :rel_fields FROM :rel_name WHERE masterid in [:rel_ids]',
                     {
			 params: {
			     rel_fields: ,
			     rel_name: ,
			     rel_ids:
			 }
		     }).then(function(result) {
			 // instantiate relationship model
		     });*/
	};

	this._performSave = function(object, callback) {
	    if(!object.masterid) {
		return callback('Item must have a masterid', object);
	    }

	    if(_rid) {
		// Item already exists, update it
		db.update(entityClass).set(_.pick(object, fields))
		    .where({'@rid': _rid}).scalar()
		    .then(function(count) {
			if(callback) {
			    if(count == 1) {
				callback(null, object);
				//_updateRelationships(object, callback);
			    } else if(count == 0) {
				callback('Item not saved. Bad masterid?', object);
			    } else {
				callback('Multiple items saved... this isn\'t good.', object);
			    }
			}
		    }).done();
	    } else {
		// Item doesn't exist, create it
		db.select('count(masterid)').from(entityClass)
		    .where({'masterid': object.masterid})
		    .scalar().then(function(count) {
			if(count > 0) {
			    return callback('A ' + entityClass + 'with that masterid already exists', object);
			}
			db.insert().into(entityClass)
			    .set(_.omit(object, ['_performSave', 'save', 'set'])).one()
			    .then(function(saved) {
				_rid = saved['@rid'];
				//_updateRelationships(_.omit(saved, ['@type', '@class', '@rid']), callback);
				callback(null, _.omit(saved, ['@type', '@class', '@rid']));
			    });
		    });
	    }
	};

	return this;
    };

    Model.prototype.save = function(callback) {
	this._performSave(this, callback);
    };

    Model.getNew = function(masterid, callback) {
	var fieldsList =  _.toArray(_.pick(fields, _.isString)).join(', ');

	console.log(fieldsList);

	db.query('SELECT @class as class, masterid, '+fieldsList+' FROM '+entityClass+' WHERE masterid = :masterid',
		 {
		     params: {
			 masterid: masterid
		     },
		     limit: 1
		 }).all().then(function(results) {
		     if(results[0]) {
			 // deep fetch here
			 callback(null, _.omit(results[0], ['@type', '@rid']));
		     } else {
			 callback("no record found with that masterid", null);
		     }
		 });
    };

    Model.get = function(masterid, callback) {
	db.select('@rid, masterid, ' + fields.join(', '))
	    .from(entityClass)
	    .where({masterid: masterid})
	    .limit(1)
	    .one()
	    .then(function(result) {
		if(!result) { return callback('No record found', null); }
		// do relationship fetching here? or in a function? 
		callback(null, new Model(result.masterid, result, result.rid));
	    }).done();
    };

    return Model;
};

module.exports = ConstructModel;
